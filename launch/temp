#include <iostream>
#include <string>

#include <ctime>

#include "table_recon/ObjectCloudNode.h"
#include <darknet_ros/ObjectInfo.h>
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/conversions.h>

#include <tf/tf.h>
#include <pcl_ros/impl/transforms.hpp>


using namespace std;

pthread_mutex_t ObjectCloudNode::visualOdom_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t ObjectCloudNode::pointCloud_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t ObjectCloudNode::cameraInfo_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t ObjectCloudNode::depthImg_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t ObjectCloudNode::rgbImg_mutex = PTHREAD_MUTEX_INITIALIZER;

ObjectCloudNode::ObjectCloudNode()
{
	srand (time(NULL));
	objectCloud_pub = nh.advertise<sensor_msgs::PointCloud2>("/object_pc",1);
	objectDepth_pub = nh.advertise<sensor_msgs::Image>("/object_depth",1);
	objectImg_pub = nh.advertise<sensor_msgs::Image>("/object_img",1);
	
	visualOdom_sub = nh.subscribe("/rtabmap/odom",100, &ObjectCloudNode::visualOdomCb, this);
	pointCloud_sub = nh.subscribe("/camera/depth_registered/points", 100, &ObjectCloudNode::pointCloudCb, this);
	depthImg_sub = nh.subscribe("/camera/depth_registered/image_raw", 100, &ObjectCloudNode::depthImgCb, this);
	rgbImg_sub = nh.subscribe("/camera/rgb/image_rect_color", 100, &ObjectCloudNode::rgbImgCb, this);
	cameraInfo_sub = nh.subscribe("/camera/rgb/camera_info", 100, &ObjectCloudNode::cameraInfoCb, this);
	detectionWindow_sub = nh.subscribe("/darknet_ros/detected_objects", 100, &ObjectCloudNode::detectionWindowCb, this);
}

ObjectCloudNode::~ObjectCloudNode()
{
	time_t rawtime;
	struct tm * timeinfo;
	char buffer[80];

	time (&rawtime);
	timeinfo = localtime(&rawtime);

	strftime(buffer,80,"%Y%y%d_%I%M%S",timeinfo);
	
	pcl::io::savePCDFileASCII(string(buffer), objectCloud);
}

/**
 *	Receive Visual Odometry from rtabmap
 */
void ObjectCloudNode::visualOdomCb(const nav_msgs::OdometryPtr odomPtr)
{
	pthread_mutex_lock(&visualOdom_mutex);
	cout<<"getting odom"<<endl;
	visualOdomPtr = odomPtr;
	pthread_mutex_unlock(&visualOdom_mutex);
}

/**
 *	Receive Depth Image
 */
void ObjectCloudNode::depthImgCb(const sensor_msgs::ImagePtr depthImgPtr)
{
	pthread_mutex_lock(&depthImg_mutex);
	depthImg = *depthImgPtr;
	pthread_mutex_unlock(&depthImg_mutex);
}

/**
 *	Receive RGB Image
 */
void ObjectCloudNode::rgbImgCb(const sensor_msgs::ImagePtr rgbImgPtr)
{
	pthread_mutex_lock(&rgbImg_mutex);
	rgbImg = *rgbImgPtr;
	pthread_mutex_unlock(&rgbImg_mutex);
}

/**
 *		Receive current visible dense point cloud
 */
void ObjectCloudNode::pointCloudCb(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr& cloud)	
{
	pthread_mutex_lock(&pointCloud_mutex);
	if(cameraInfo.header.seq==0)
		return;
	pixelCloud = *cloud;
	pthread_mutex_unlock(&pointCloud_mutex);
}

/**
 *	Receive PTAM Info
 */
void ObjectCloudNode::cameraInfoCb(const sensor_msgs::CameraInfoPtr cameraInfoPtr)
{
	pthread_mutex_lock(&cameraInfo_mutex);
	cameraInfo = *cameraInfoPtr;
	pthread_mutex_unlock(&cameraInfo_mutex);
}	

void ObjectCloudNode::detectionWindowCb(const darknet_ros::DetectedObjectsPtr objectsPtr)
{
	if(!depthImg.encoding.compare("") or !rgbImg.encoding.compare(""))
		return;
	cout<<"starting detection"<<endl;
	depthPtr_ = cv_bridge::toCvCopy( depthImg, sensor_msgs::image_encodings::TYPE_16UC1 );
	cout<<"copied depth"<<endl;
	rgbPtr_ = cv_bridge::toCvCopy( rgbImg, sensor_msgs::image_encodings::BGR8 );
	cout<<"copied rgb"<<endl;
	int minHeight = (depthImg.height < rgbImg.height) ? depthImg.height : rgbImg.height;
	int minWidth = (depthImg.width < rgbImg.width) ? depthImg.width : rgbImg.width;
	cout<<"matting images"<<endl;
	cv::Mat depthTarget(depthPtr_->image.size(), depthPtr_->image.type()),
			rgbTarget(rgbPtr_->image.size(), rgbPtr_->image.type()); 

	cout<<"init depth"<<endl;
	depthTarget = cv::Scalar(0);
	cout<<"init rgb"<<endl;
	rgbTarget = cv::Scalar(0,0,0);
	cout<<"clearing pc"<<endl;
	objectCloud.points.clear();
	objectCloud.width = 1;
	cout<<"starting objects "<<objectsPtr->objects.size()<<endl;
	for(int i=0;i<objectsPtr->objects.size();i++)
	{
		if((!objectsPtr->objects[i].type.compare("chair") or !objectsPtr->objects[i].type.compare("table")) )
			//and objectsPtr->objects[i].prob>0.4)	
		{
			cout<<"got object "<<i<<endl;
			darknet_ros::ObjectInfo obj = objectsPtr->objects[i];
			if(obj.tl_x+obj.width >= minWidth)
				obj.width = minWidth-obj.tl_x;
			if(obj.tl_y+obj.height >= minHeight)
				obj.height = minHeight-obj.tl_y;
			cout<<"clouding object "<<i<<endl;
			for(int j=obj.tl_x;j<obj.tl_x+obj.width;j++)
				for(int k=obj.tl_y;k<obj.tl_y+obj.height;k++)
				{
					cout<<j<<" "<<k<<" "<<pixelCloud.width*k + j<<endl;
					objectCloud.points.push_back(pixelCloud.points[pixelCloud.width*k + j]);
				}
			cout<<"cropping depth object "<<i<<endl;
			cv::Mat subImage = depthTarget(cv::Rect(obj.tl_x, obj.tl_y, obj.width, obj.height));
			cout<<"setting depth object "<<i<<endl;
			depthPtr_->image(cv::Rect(obj.tl_x, obj.tl_y, obj.width, obj.height)).copyTo(subImage);
			cout<<"cropping rgb object "<<i<<endl;
			subImage = rgbTarget(cv::Rect(obj.tl_x, obj.tl_y, obj.width, obj.height));
			cout<<"setting rgb object "<<i<<endl;
			rgbPtr_->image(cv::Rect(obj.tl_x, obj.tl_y, obj.width, obj.height)).copyTo(subImage);
			cout<<"finished object "<<i<<endl;
		}
		
		sensor_msgs::ImagePtr msg_1;
		msg_1->header.frame_id = "camera_rgb_optical_frame";
		msg_1->header.stamp = ros::Time::now();
		cout<<"setting depth image"<<endl;
		msg_1 = cv_bridge::CvImage(std_msgs::Header(), "mono16", depthTarget).toImageMsg();
		cout<<"publishing depth image"<<endl;
		objectDepth_pub.publish(msg_1);
		cout<<"setting rgb image"<<endl;
		msg_1 = cv_bridge::CvImage(std_msgs::Header(), "bgr8", rgbTarget).toImageMsg();
		cout<<"publishing rgb image"<<endl;
		objectImg_pub.publish(msg_1);
	}
	objectCloud.height = objectCloud.points.size();
	cout<<"declaring TF"<<endl;
	//tf::Pose poseTF;
	/*pthread_mutex_lock(&visualOdom_mutex);
	cout<<"converting odom to TF"<<endl;
	if(visualOdomPtr!=NULL)
		tf::poseMsgToTF(visualOdomPtr->pose.pose, poseTF);
	pthread_mutex_unlock(&visualOdom_mutex);*/

	
	//pcl::PointCloud<pcl::PointXYZRGB> cloud;
	cout<<"TFing cloud"<<endl;
	//pcl_ros::transformPointCloud(objectCloud, cloud, poseTF);
	cout<<"pcl to ros msg"<<endl;
	pcl::toROSMsg(objectCloud, pc);
	pc.header.frame_id = "camera_rgb_optical_frame";
	pc.header.stamp = ros::Time::now();
	objectCloud_pub.publish(pc);
}
